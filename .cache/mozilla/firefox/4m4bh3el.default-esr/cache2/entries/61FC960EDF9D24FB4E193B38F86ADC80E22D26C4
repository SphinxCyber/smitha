/* Apply ShellCheck fixes to code.
 *
 * This specific file, autofix.js, is released into the public domain.
 * Please feel free to use it however you see fit.
 */


function AutoFixer(file) {
  // Apply a list of fixes (either comments or their .fix values).
  // Returns an object with .applied and .rejected fixes.
  function applyFixes(fixlist) {
    var result = {
      applied: [],
      rejected: [],
    };
    for (var fix of fixlist) {
      if (this.applyFix(fix)) {
        result.applied.push(fix);
      } else {
        result.rejected.push(fix);
      }
    }

    return result;
  }

  // Try to apply a single fix. Return true if it could be applied (without conflicting with previous ones).
  function applyFix(item) {
    var fix = item;
    var candidates = [];

    if(!fix) {
      return false;
    }

    if (fix.fix) {
      // If this is a comment, grab the fix instead.
      fix = fix.fix;
    }

    // Who knows what this is...
    if(!fix || fix.replacements === undefined) {
      return false;
    }

    // TODO: Make this less quadratic
    for (var rep of fix.replacements) {
      var candidate = {
        start: getOffsetFor.call(this, rep.line, rep.column),
        end: getOffsetFor.call(this, rep.endLine, rep.endColumn),
        startLine: rep.line,
        endLine: rep.endLine,
        precedence: rep.precedence,
        point: rep.insertionPoint,
        text: rep.replacement,
      };
      candidates.push(candidate);

      for (var existing of this._replacements) {
        if (candidate.end > existing.start && existing.end > candidate.start) {
          return false;
        }
      }
    }

    this._replacements = this._replacements.concat(candidates);
    return true;
  }

  // Get the file with relevant fixes applied.
  function getResult() {
    this._replacements.sort(function (a,b) {
      return b.precedence - a.precedence;
    });
    var tree = new PrefixSumTree();
    var file = this._file;

    for (var rep of [...this._replacements].reverse()) {
      file = applyReplacement(file, tree, rep);
    }
    return file;
  }

  // Get the parts of the file from first to last affected line.
  function getSnippet() {
    if(this._replacements.length == 0) {
      throw new Error("No fixes have been applied.");
    }

    this._replacements.sort(function (a,b) {
      return b.precedence - a.precedence;
    });

    var tree = new PrefixSumTree();
    var file = this._file;
    var minLine = this._replacements[0].startLine;
    var maxLine = this._replacements[0].endLine;


    for (var rep of [...this._replacements].reverse()) {
      file = applyReplacement(file, tree, rep);
      minLine = Math.min(minLine, rep.startLine);
      maxLine = Math.max(maxLine, rep.endLine);
    }

    // Get offset of the minimal line
    var startOffset = this._lineOffsets[minLine-1];
    // Get offset up to and including the last line
    var endOffset = this._lineOffsets[maxLine];
    // Adjust end offset. The start offset should never need adjustment
    // because all fixes happened on/after it.
    endOffset += tree.lookup(endOffset);

    return file.substring(startOffset, endOffset);
  }

  // Compute the character offset of the start of each line in the file.
  function getLineOffsets(lines) {
    var sum = 0;
    var offsets = [];
    for (var i=0; i<lines.length; i++) {
      offsets[i] = sum;
      sum += lines[i].length + 1;
    }
    offsets[i] = sum;
    return offsets;
  }

  // ShellCheck operates with standard 8 column tab stops.
  // Realign them to 1, so that a '\t' is a single character.
  // Return the new column number.
  function adjustTabStops(lineNo, columnNo) {
    // ShellCheck operates with editor style 1-based line numbering
    var line = this._lines[lineNo-1];
    var tabstop = 8;

    var logical = 0;
    var physical = 0;
    for(var i=0, e=line.length; i < e; i++) {
      if(line[i] === '\t') {
        logical += tabstop - (logical % tabstop);
      } else {
        logical++;
      }

      if (columnNo <= logical) {
        return i+1;
      }
    }
    // The original fix was invalid...
    return i+1;
  }

  // Get the offset into the original file, 0-indexed
  function getOffsetFor(line, col) {
    return this._lineOffsets[line-1] + adjustTabStops.call(this, line, col) - 1;
  }

  // Apply a single replacement. The highest precedence ones should be applied first.
  // Note that these refer to replacements as generated by `applyFixes`, and not raw json.
  function applyReplacement(file, tree, rep) {
    // Get the offset into the original file
    var from = rep.start;
    var to   = rep.end;
    // Get offset into the current state of the modified file
    from += tree.lookup(from);
    to += tree.lookup(to);

    file = file.substring(0, from) + rep.text + file.substring(to);

    var point;
    if (rep.point == "beforeStart") {
      point = rep.start;
    } else if(rep.point == "afterEnd") {
      point = rep.end + 1;
    } else {
      throw new Error("Unrecognized insertion point " + rep.point);
    }
    tree.insert(point, rep.text.length - (to-from));
    return file;
  }

  function PrefixSumTree() {
    function insert(node, point, value) {
      do {
        if (point < node.pivot) {
          node.sumLeft += value;
          if (!node.left) {
            node.left = {
              pivot: point,
              sumLeft: value,
            };
            return;
          }
          node = node.left;
        } else if (point > node.pivot) {
          if (!node.right) {
            node.right = {
              pivot: point,
              sumLeft: value,
            };
            return;
          }
          node = node.right;
        } else {
          node.sumLeft += value;
          return;
        }
      } while(true);
    }

    function lookup(node, point) {
      var sum = 0;
      do {
        if (point < node.pivot) {
          node = node.left;
        } else if (point > node.pivot) {
          sum += node.sumLeft;
          node = node.right;
        } else {
          sum += node.sumLeft;
          node = null;
        }
      } while(node);
      return sum;
    }

    return {
      tree: {
        pivot: 0,
        sumLeft: 0,
      },

      insert: function(point, value) {
        return insert(this.tree, point, value);
      },

      lookup: function(point) {
        return lookup(this.tree, point);
      },

      reset: function () {
        this.tree = { pivot: 0, sumLeft: 0 };
      }
    }
  }

  var lines = file.split("\n");
  return {
    _file: file,
    _lines: lines,
    _lineOffsets: getLineOffsets(lines),
    _replacements: [],

    applyFix: applyFix,
    applyFixes: applyFixes,
    getResult: getResult,
    getSnippet: getSnippet,
    hasModifications: function() {
      return this._replacements.length > 0;
    },
    reset: function() {
      this._replacements = [];
    }
  }
}


function autofixTest() {
  function assertEqual(expected, actual) {
    if(expected != actual) {
      throw ("Failed to apply fixes: " + expected + " != " + actual);
    }
  }

  function test(initial, expected, fixes) {
    var fixer = new AutoFixer(initial);
    fixer.applyFixes(fixes);
    var actual = fixer.getResult();
    assertEqual(expected, actual);
  };

  test("cd $1", "cd \"$1\" || exit", [
    {
      "file": "-",
      "line": 1,
      "endLine": 1,
      "column": 1,
      "endColumn": 6,
      "level": "warning",
      "code": 2164,
      "message": "Use 'cd ... || exit' or 'cd ... || return' in case cd fails.",
      "fix": {
        "replacements": [
          {
            "line": 1,
            "endLine": 1,
            "precedence": 5,
            "insertionPoint": "beforeStart",
            "column": 6,
            "replacement": " || exit",
            "endColumn": 6
          }
        ]
      }
    },
    {
      "file": "-",
      "line": 1,
      "endLine": 1,
      "column": 4,
      "endColumn": 6,
      "level": "info",
      "code": 2086,
      "message": "Double quote to prevent globbing and word splitting.",
      "fix": {
        "replacements": [
          {
            "line": 1,
            "endLine": 1,
            "precedence": 7,
            "insertionPoint": "afterEnd",
            "column": 4,
            "replacement": "\"",
            "endColumn": 4
          },
          {
            "line": 1,
            "endLine": 1,
            "precedence": 7,
            "insertionPoint": "beforeStart",
            "column": 6,
            "replacement": "\"",
            "endColumn": 6
          }
        ]
      }
    }
  ]);

  test("\t\tfoo bar\n\t\techo $var:\t$value", "\t\tfoo bar\n\t\techo \"$var\":\t\"$value\"", [
    {
      "file": "-",
      "line": 2,
      "endLine": 2,
      "column": 33,
      "endColumn": 39,
      "level": "info",
      "code": 2086,
      "message": "Double quote to prevent globbing and word splitting.",
      "fix": {
        "replacements": [
          {
            "line": 2,
            "endLine": 2,
            "precedence": 7,
            "insertionPoint": "afterEnd",
            "column": 33,
            "replacement": "\"",
            "endColumn": 33
          },
          {
            "line": 2,
            "endLine": 2,
            "precedence": 7,
            "insertionPoint": "beforeStart",
            "column": 39,
            "replacement": "\"",
            "endColumn": 39
          }
        ]
      }
    },
    {
      "file": "-",
      "line": 2,
      "endLine": 2,
      "column": 22,
      "endColumn": 26,
      "level": "info",
      "code": 2086,
      "message": "Double quote to prevent globbing and word splitting.",
      "fix": {
        "replacements": [
          {
            "line": 2,
            "endLine": 2,
            "precedence": 7,
            "insertionPoint": "afterEnd",
            "column": 22,
            "replacement": "\"",
            "endColumn": 22
          },
          {
            "line": 2,
            "endLine": 2,
            "precedence": 7,
            "insertionPoint": "beforeStart",
            "column": 26,
            "replacement": "\"",
            "endColumn": 26
          }
        ]
      }
    }
  ]);


  var fixer = new AutoFixer('foo\ncd foo\nbar\n');
  fixer.applyFix(
    {
      "replacements": [
        {
          "line": 2,
          "endLine": 2,
          "precedence": 5,
          "insertionPoint": "beforeStart",
          "column": 7,
          "replacement": " || exit",
          "endColumn": 7
        }
      ]
    });
  assertEqual("cd foo || exit\n", fixer.getSnippet());
  return true;
}
£Ùã8m      eõ:9eõ:9F«þeù2å   R    O^partitionKey=%28https%2Cshellcheck.net%29,:https://www.shellcheck.net/autofix.js necko:classified 1 strongly-framed 1 security-info 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 request-method GET response-head HTTP/1.1 200 OK
Date: Sat, 16 Mar 2024 06:20:41 GMT
Server: Apache/2.4.58 (Debian)
Last-Modified: Thu, 15 Feb 2024 03:22:33 GMT
ETag: "297c-61163235ef814"
Accept-Ranges: bytes
Content-Length: 10620
Content-Type: text/javascript
 original-response-headers Date: Sat, 16 Mar 2024 06:20:41 GMT
Server: Apache/2.4.58 (Debian)
Last-Modified: Thu, 15 Feb 2024 03:22:33 GMT
ETag: "297c-61163235ef814"
Accept-Ranges: bytes
Content-Length: 10620
Keep-Alive: timeout=15, max=99
Connection: Keep-Alive
Content-Type: text/javascript
 ctid 2 uncompressed-len 0 net-response-time-onstart 537 net-response-time-onstop 537   )|